\week[description={Last week we discussed information. This week we start to understand that combining information with decision making is the foundation on which we can build complex behaviors.}]{Making Decisions}

\resource[silent,files={motherduck.html},description={Play the DuckBot game online},text={DuckBot}]{demos/duckbot.html}
\resourcegen{name=data/duckbot.tar.gz, type={archive}, from={week3 game.py sample_brain.py assets/tileset.json assets/maps/level1.json assets/duck.png assets/terrain_atlas.png}}
\resourcegen{name=demos/duckbot.html, from=week3/site/duckbot.html, type={jinja}}

The ancient Greek polymath Eratosthenes regularly traveled between the Egyptian cities of Syene and
Alexandria (see \prettyref{fig:alexandria}). He was a very observant scientist, and -- like many
ancient polymaths -- was interested in astronomy. He noticed that, on the summer solstice, the
following things were true (see \prettyref{fig:eratosthenes}):
\begin{marginfigure}
  \centering
  \includegraphics[width=0.9\marginparwidth]{../week3/figures/syene-alexandria.jpg}

  \caption{The distance between the Egyptian cities of Alexandria and Syene is 5000 stadia or approximately 787.5 kilometers apart.}
  \label{fig:alexandria}
\end{marginfigure}

\begin{enumerate}
\item In Syene, which was south of Alexandria, on the summer solstice, the sun shone straight down. If he looked at the bottom of a deep well, there were no shadows at all. If you planted a stick in the ground, the stick would cast no shadow, because the sun was directly overhead.
\item In Alexandria, to the north, on the same day at the same time, if you planted a stick in the ground, there was a shadow.
\end{enumerate}

What can be deduced based off these two observations?

Here's some more details: the straight-line distance between the two cities is approximately 787.5
kilometers apart. Also, the angle of the shadow cast on the ground in Alexandria was $7.5^{\circ}$.

Eratosthenes did the following calculation:

\[
\underbrace{787.5\;\text{kilometers}}_{\text{distance between the two cities}} \times \frac{360^{\circ}}{7.5^{\circ}} \approx 40,000\;\text{kilometers}
\]

\begin{figure}
  \centering

  \begin{tikzpicture}[scale=0.5,font={\sffamily}]
    \node at (0, 10) {Sun};
    \draw (0, 10) circle (1);
    \draw (-2, 0) -- (10, 0) node[midway, anchor=north, yshift=-0.1em] {Ground};

    \draw (0,0) -- (0, 4);

    \coordinate (alexandria bottom) at (6, 0);
    \coordinate (alexandria stick) at (6, 4);

    \path[name path=ray] (alexandria stick) -- ++(-82.5:100);
    \path[name path=x axis] (-10, 0) -- (10, 0);
    \fill[name intersections={of=ray and x axis, by=B}, dashed, fill=lightgray]
      (alexandria bottom) -- (alexandria stick) -- (B);
    \draw (alexandria bottom) -- (alexandria stick);
    \draw[dashed] (alexandria stick) -- (B);
    \draw[ultra thick] (B) -- (alexandria bottom);

  \end{tikzpicture}

  \caption{Eratosthenes noticed that on the summer solstice the shadows cast by the Sun at noon appeared different in two cities. In Syene, there was no shadow, which meant the Sun was directly overhead. In Alexandria, there was a shadow.}
  \label{fig:eratosthenes}
\end{figure}

\didyouknow{
Albert Einstein famously came up with his theory of special relativity by simply thinking about it!
If you ever study physics in depth, you'll discover that the entirety of special relativity falls
out of two simple facts:
\begin{enumerate}
\item The speed of light is the same for everyone.
\item The relationship between the sides of the triangle: $c^2 = a^2 + b^2$.
\end{enumerate}
Einstein used these simple facts to show that light actually travels less distance in moving
reference frames, leading to one of the most surprising facts about our universe: fast things become
shorter.  }
\begin{BigIdeaBox}
As humans, we only see our part of the world and our part of the universe. The consistent
application of precise rules lets us reason about things larger than what we can directly perceive.

Despite having no possible way to observe the entirety of the planet. Eratosthenes used simple rules
of logic and simple observations to deduce a global truth.
\end{BigIdeaBox}

\section{Week 2 Review}

Last week, we discussed breaking down large drawings and objects into
smaller elements. Doing so let us build large drawings from simple
drawings we could combine together. Even though the set of simple
or \term{primitive} drawings were small, we could draw quite a bit
with them.

\section{Understanding Big Things}

The Turtle cursor we saw last week simply knew what was around it. We
gave it commands based on its \emph{immediate} environment and based
on those, it simply followed what we told it. It was up to us to give
it the set of rules necessary to make the drawings we wanted.

We can use a similar idea to understand large things. It's impossible
to build a system large enough to be able to ``see'' the entire set of
things we'd ever want to talk about. Just like Eratosthenes, we are
limited in what we are able to perceive. Similarly, computers can only
perceive a few things directly, yet we are able to build very complex
systems with them.

How can we use small rules to understand large things? Once again, we have to be clear about our
language. We have to understand what we can see and what we can do with that information. When our
rules are designed to ingest and understand information, we call that
an \term{algorithm}. \didyouknow{The word \emph{algorithm} comes from the name of the Persian
polymath and mathematician al-Khw\={a}rizm\={i} who introduced the idea of algorithms to the West
via his book \emph{kit\={a}b al-\d{h}is\={a}b al-hind\={i}} (``Book of Indian Computation''). This
book was translated into Latin by Robert Chester in 1145, and was the principal mathematics textbook
used in many universities for almost four centuries. Many of our modern methods of addition,
subtraction, division, and multiplication come from his translations!
\vspace{1em}
\begin{center}
  \includegraphics[width=0.6\marginparwidth]{../week3/figures/al-kwharizmi.jpg}
\end{center}}

In order to learn and understand algorithms, we are going to play a simple game. But be
warned... this is not like any game you've played before!

\section{Introducing DuckBot!}

Meet DuckBot! DuckBot has been put in change of a group of three very sneaky little ducklings while
Mother Duck has gone away. But those sneaky little ducklings have fried DuckBot's brain and have run
off. They are now hiding in some corner of the pond. DuckBot needs to find the ducklings before
Mother Duck gets back.

Your job is to give DuckBot a new brain so that it can find the ducklings!

Oh and one more thing: if DuckBot runs into any obstacle, like a rock, a plant, or the ground,
DuckBot dies and will never be able to make it to the ducklings. Your brain has to make sure he only
ever swims in water.

The DuckBot game window (see \prettyref{fig:duckbot}) has four parts:
\begin{enumerate}
\item This shows you where DuckBot is in the pond. You can change your view of the pond by using the
  arrow keys or dragging around with your mouse. You can zoom in or out using the mouse wheel or the
  \litkey{+} and \litkey{-} keys. But remember, whatever you can see doesn't matter, because DuckBot
  can only see what's immediately around it.

\item The brain pane shows you the current Python code in DuckBot's brain. DuckBot runs this code
  each time it moves a square in the pond, in order to decide what to do next. You can edit the code
  here to make DuckBot do what you want.

\item The bottom pane shows you what DuckBot sees. DuckBot can see obstacles in all four cardinal
  directions.

\item The controls pane lets you control DuckBot. You can make DuckBot go or stop by clicking the ``Start Duck'' and ``Stop Duck'' buttons. You can reset the game by clicking the ``Reset Game'' button.\hint{You'll need to stop the duck before resetting the game or reloading DuckBot's brain} When you've made changes to your brain, you have to tell DuckBot to switch to the new brain by clicking the ``Reload Brain'' button.

\end{enumerate}

\subsection{Programming DuckBot}

DuckBot is programmed in Python. The goal of the game is to write a program so that DuckBot swims
over \emph{every} portion of the pond it can reach. The ducklings are \emph{very} sneaky and always
stay in the spot in which DuckBot is least likely to find them. Thus, DuckBot really must visit
every single portion of the pond.

The pond is arranged in a grid. DuckBot moves one square at a time. Once a square on the grid has
been swam over it turns darker, but DuckBot cannot see if it's already swam over a particular
square. It only sees what's around it and responds.

Every time DuckBot moves to a new square, the brain code is run again. The brain decides two things:

\begin{enumerate}

\item The \textbf{direction} that DuckBot ought to go in next.

\item The \textbf{thought} that DuckBot ought to think.

\end{enumerate}

\subsection{DuckBot's memory}

As we said before, DuckBot's brain is totally fried and so is its memory. DuckBot can only remember
the last thing you told it. This is called its \emph{thought}.\curious{DuckBot's thought is an
  example of \term{state}.} DuckBot can see what's around it in the current square. Based off of
this knowledge \emph{and} its previous thought, DuckBot has to decide the next direction and its
next thought.

You can see DuckBot's current thought in the information pane beneath the pond. When you first start DuckBot, its thought is the number $0$.

\section{Numbers All the Way Down}

Last week, we discussed how computers store numbers using switches that are either on or
off. \hint{See \prettyref{sec:binary-numbers} for a review.}

Everything on a computer is stored as numbers. Even the words we saw last class are stored using
numbers. Every letter in a word (or a \term{string} as Python calls it) is assigned a number. We
call these numbers the \term{encoding} of the string.\hint{Python will sometimes abbreviate \term{string} as \code{str}.}

Most modern computers today use the \term{Unicode} standard for encoding strings. Unicode is a
\emph{huge} dictionary mapping every character possibly known to humans to a number assigned by an
international committee.\didyouknow{As of the latest Unicode standard, there are over 297,334
  characters! That's a lot of letters!} Before Unicode standardized the mapping of characters,
computer systems would often use their own custom standard or a standard particular to individual
countries and languages. Reading files created using one standard on a computer designed to work
with another standard could result in garbage data. Another common way to write strings as numbers
is called \term{ASCII}, which stands for the \emph{American Standard Code for Information
Interchange}. ASCII covers most characters used in English and other languages that use the Latin
alphabet. It's also compatible with Unicode -- Unicode maps every Latin letter to the same ASCII
character.

It may seem crazy that each letter has a number that goes along with it, but I can prove it to you. Try this in Python:

\hint{If you want to see a new kind of error called a \code{ValueError}, try\\
\code{ord('hello')}!}
\begin{replbox}
>>> ord('5')<ENTER>
53
>>> ord('Z')<ENTER>
90
>>> ord('>')<ENTER>
62
>>> ord('\'')<ENTER>(*@ \tikzmarknode{python escapes node}{} @*)
39
>>> ord('h')<ENTER>
104
\end{replbox}
\makemargmark{python escapes node}{\notestyle\hintnote Python words are delimited by single quotation marks (\code{'}). But what if you want to talk about the word consisting of just the single quote character itself or a word containing a single quote character (like an Irish name with \enquote{O'})? In order to tell Python that you want a \code{'} treated as just the letter and not part of the Python rules, you use the \code{\textbackslash} character in front of it. This word \code{'\textbackslash''} is just the word consisting of a single single-quote letter.}
%}


You can also go from a number \emph{to} a word.

\hint{Try all kinds of numbers here, and see what you get!}
\begin{replbox}
>>> chr(76)<ENTER>
'L'
>>> chr(53)<ENTER>
'5'
>>> chr(54)<ENTER>
'6'
>>> chr(233)<ENTER>
'Ã©'
>>> chr(1103)<ENTER>
'Ñ'
>>> chr(26159)<ENTER>
'æ˜¯'
>>> chr(22398)<ENTER>
'å­¦'(*@\tikzmarknode{chinese xie}{}@*)
>>> chr(128512)<ENTER>
'(*@{\EmojiFont ðŸ˜€}@*)'
\end{replbox}
\makemargmark{chinese xie}{\hintnote \enquote{å­¦}(\emph{xi\`e}) means to learn in Mandarin. That's what we're doing right now, and you just learned something new!}

Lest we forget that it's still all just ones and zeros, you can use the \code{bin} rule that we
learned about last week to see the binary representation of these numbers.

\begin{replbox}
>>> bin(ord('5'))<ENTER>
'0b100111'(*@\tikzmarknode{single quotes around binary numbers}{}@*)
>>> bin(ord('Z'))<ENTER>
'0b1011010'
>>> bin(ord('\''))<ENTER>
'0b100111'
\end{replbox}
\makemargmark{single quotes around binary numbers}{\notestyle\huhnote{I thought the single quotes meant words. Why do we keep seeing them when we ask for binary numbers?}\\
Because Python is friendly, it always shows numbers as decimal, even though they are stored as binary on the computer. The \code{bin} rule actually creates a word, or string, that represents the binary representation. This lets you see it here.}

See it's just numbers all the way down!

\begin{BigIdeaBox}
  All information inside a modern computer is stored as numbers, even words!
\end{BigIdeaBox}
