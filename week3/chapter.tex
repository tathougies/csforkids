% -*- mode: latex -*-

\week[description={Last week we discussed information. This week we start to understand that combining information with decision making is the foundation on which we can build complex behaviors.}]{Making Decisions}

\resource[silent,files={motherduck.html},description={Play the DuckBot game online},text={DuckBot}]{demos/duckbot.html}
\resourcegen{name=data/duckbot.tar.gz, type={archive}, from={week3 game.py sample_brain.py assets/tileset.json assets/maps/level1.json assets/maps/level2.json assets/maps/level3.json assets/duck.png assets/terrain_atlas.png}}
\resourcegen{name=demos/duckbot.html, from=week3/site/duckbot.html, type={jinja}}

The ancient Greek polymath Eratosthenes regularly traveled between the Egyptian cities of Syene and
Alexandria (see \prettyref{fig:alexandria}). He was a very observant scientist, and -- like many
ancient polymaths -- was interested in astronomy. He noticed that, on the summer solstice, the
following things were true (see \prettyref{fig:eratosthenes}):
\begin{marginfigure}
  \centering
  \includegraphics[width=0.9\marginparwidth]{../week3/figures/syene-alexandria.jpg}

  \caption{The distance between the Egyptian cities of Alexandria and Syene is 5000 stadia or approximately 787.5 kilometers apart.}
  \label{fig:alexandria}
\end{marginfigure}

\begin{enumerate}
\item In Syene, which was south of Alexandria, on the summer solstice, the sun shone straight down. If he looked at the bottom of a deep well, there were no shadows at all. If you planted a stick in the ground, the stick would cast no shadow, because the sun was directly overhead.
\item In Alexandria, to the north, on the same day at the same time, if you planted a stick in the ground, there was a shadow.
\end{enumerate}

What can be deduced based off these two observations?

Here's some more details: the straight-line distance between the two cities is approximately 787.5
kilometers apart. Also, the angle of the shadow cast on the ground in Alexandria was $7.5^{\circ}$.

Eratosthenes did the following calculation:

\[
\underbrace{787.5\;\text{kilometers}}_{\text{distance between the two cities}} \times \frac{360^{\circ}}{7.5^{\circ}} \approx 40,000\;\text{kilometers}
\]

\begin{figure}
  \centering

  \begin{tikzpicture}[scale=0.5,font={\sffamily}]
    \node at (0, 10) {Sun};
    \draw (0, 10) circle (1);
    \draw (-2, 0) -- (10, 0) node[midway, anchor=north, yshift=-0.1em] {Ground};

    \draw (0,0) -- (0, 4);

    \coordinate (alexandria bottom) at (6, 0);
    \coordinate (alexandria stick) at (6, 4);

    \path[name path=ray] (alexandria stick) -- ++(-82.5:100);
    \path[name path=x axis] (-10, 0) -- (10, 0);
    \fill[name intersections={of=ray and x axis, by=B}, dashed, fill=lightgray]
      (alexandria bottom) -- (alexandria stick) -- (B);
    \draw (alexandria bottom) -- (alexandria stick);
    \draw[dashed] (alexandria stick) -- (B);
    \draw[ultra thick] (B) -- (alexandria bottom);

  \end{tikzpicture}

  \caption{Eratosthenes noticed that on the summer solstice the shadows cast by the Sun at noon appeared different in two cities. In Syene, there was no shadow, which meant the Sun was directly overhead. In Alexandria, there was a shadow.}
  \label{fig:eratosthenes}
\end{figure}

\didyouknow{
Albert Einstein famously came up with his theory of special relativity by simply thinking about it!
If you ever study physics in depth, you'll discover that the entirety of special relativity falls
out of two simple facts:
\begin{enumerate}
\item The speed of light is the same for everyone.
\item The relationship between the sides of the triangle: $c^2 = a^2 + b^2$.
\end{enumerate}
Einstein used these simple facts to show that light actually travels less distance in moving
reference frames, leading to one of the most surprising facts about our universe: fast things become
shorter.  }
\begin{BigIdeaBox}
As humans, we only see our part of the world and our part of the universe. The consistent
application of precise rules lets us reason about things larger than what we can directly perceive.

Despite having no possible way to observe the entirety of the planet. Eratosthenes used simple rules
of logic and simple observations to deduce a global truth.
\end{BigIdeaBox}

\section{Week 2 Review}

Last week, we discussed breaking down large drawings and objects into
smaller elements. Doing so let us build large drawings from simple
drawings we could combine together. Even though the set of simple
or \term{primitive} drawings were small, we could draw quite a bit
with them.

\section{Understanding Big Things}

The Turtle cursor we saw last week simply knew what was around it. We
gave it commands based on its \emph{immediate} environment and based
on those, it simply followed what we told it. It was up to us to give
it the set of rules necessary to make the drawings we wanted.

We can use a similar idea to understand large things. It's impossible
to build a system large enough to be able to ``see'' the entire set of
things we'd ever want to talk about. Just like Eratosthenes, we are
limited in what we are able to perceive. Similarly, computers can only
perceive a few things directly, yet we are able to build very complex
systems with them.

How can we use small rules to understand large things? Once again, we have to be clear about our
language. We have to understand what we can see and what we can do with that information. When our
rules are designed to ingest and understand information, we call that
an \term{algorithm}. \didyouknow{The word \emph{algorithm} comes from the name of the Persian
polymath and mathematician al-Khw\={a}rizm\={i} who introduced the idea of algorithms to the West
via his book \emph{kit\={a}b al-\d{h}is\={a}b al-hind\={i}} (``Book of Indian Computation''). This
book was translated into Latin by Robert Chester in 1145, and was the principal mathematics textbook
used in many universities for almost four centuries. Many of our modern methods of addition,
subtraction, division, and multiplication come from his translations!
\vspace{1em}
\begin{center}
  \includegraphics[width=0.6\marginparwidth]{../week3/figures/al-kwharizmi.jpg}
\end{center}}

In order to learn and understand algorithms, we are going to play a simple game. But be
warned... this is not like any game you've played before!

\section{Introducing DuckBot!}

Meet DuckBot! DuckBot has been put in change of a group of three very sneaky little ducklings while
Mother Duck has gone away. But those sneaky little ducklings have fried DuckBot's brain and have run
off. They are now hiding in some corner of the pond. DuckBot needs to find the ducklings before
Mother Duck gets back.

Your job is to give DuckBot a new brain so that it can find the ducklings!

Oh and one more thing: if DuckBot runs into any obstacle, like a rock, a plant, or the ground,
DuckBot dies and will never be able to make it to the ducklings. Your brain has to make sure he only
ever swims in water.

The DuckBot game window (see \prettyref{fig:duckbot}) has four parts:
\begin{enumerate}
\item This shows you where DuckBot is in the pond. You can change your view of the pond by using the
  arrow keys or dragging around with your mouse. You can zoom in or out using the mouse wheel or the
  \litkey{+} and \litkey{-} keys. But remember, whatever you can see doesn't matter, because DuckBot
  can only see what's immediately around it.

\item The brain pane shows you the current Python code in DuckBot's brain. DuckBot runs this code
  each time it moves a square in the pond, in order to decide what to do next. You can edit the code
  here to make DuckBot do what you want.

\item The bottom pane shows you what DuckBot sees. DuckBot can see obstacles in all four cardinal
  directions.

\item The controls pane lets you control DuckBot. You can make DuckBot go or stop by clicking the ``Start Duck'' and ``Stop Duck'' buttons. You can reset the game by clicking the ``Reset Game'' button.\hint{You'll need to stop the duck before resetting the game or reloading DuckBot's brain} When you've made changes to your brain, you have to tell DuckBot to switch to the new brain by clicking the ``Reload Brain'' button.

\end{enumerate}

\subsection{Programming DuckBot}

DuckBot is programmed in Python. The goal of the game is to write a program so that DuckBot swims
over \emph{every} portion of the pond it can reach. The ducklings are \emph{very} sneaky and always
stay in the spot in which DuckBot is least likely to find them. Thus, DuckBot really must visit
every single portion of the pond.

The pond is arranged in a grid. DuckBot moves one square at a time. Once a square on the grid has
been swam over it turns darker, but DuckBot cannot see if it's already swam over a particular
square. It only sees what's around it and responds.

Every time DuckBot moves to a new square, the brain code is run again. The brain decides two things:

\begin{enumerate}

\item The \textbf{direction} that DuckBot ought to go in next.

\item The \textbf{thought} that DuckBot ought to think.

\end{enumerate}

\subsection{The Brain}

DuckBot's brain is written as a function.

% TODO figure showing the function declaration
\begin{minipage}{\textwidth}
  \tikzforeground{
    \node[anchor=south] (brain function note) at ([yshift=2em]brain function name.north) {
      \begin{tcolorbox}[code note, width=2cm]
        Your function should be named \code{brain}.
      \end{tcolorbox}
    };
  }

  \Large \ttfamily
  \begin{tcolorbox}[sharp corners]
    \kw{def} \tikzmarknode{brain function name}{brain}(\tikzmarknode{north arg}{north}, \tikzmarknode{east arg}{east}, \tikzmarknode{south arg}{south}, \tikzmarknode{west arg}{west}, \tikzmarknode{thought arg}{thought}):
  \end{tcolorbox}
\end{minipage}

\termheading{How DuckBot Perceives the World}

DuckBot can sense the four squares immediately to the North, South, East, and West of its current
location.\hint{Remember that Python requires us to surround letters and words in quotation marks.} A
blocked square is signified by the letter \code{'x'}. A free square is signified by the
letter \code{'*'}. This is illustrated in \prettyref{fig:duckbot-directions}.

\termheading{DuckBot's Memory}

As we said before, DuckBot's brain is totally fried and so is its memory. DuckBot can only remember
the last thing you told it. This is called its \emph{thought}.\curious{DuckBot's thought is an
example of \term{state}.} DuckBot can see what's around it in the current square. Based off of this
knowledge \emph{and} its previous thought, DuckBot has to decide the next direction and its next
thought.

You can see DuckBot's current thought in the information pane beneath the pond. When you first start
DuckBot, its thought is the number $0$.

\termheading{Deciding What to do Next}

In order to make DuckBot \emph{do} something, you have to give it instructions. Just like we saw
last week, to send data out of a function we use \kw{return}.

\begin{minipage}{\textwidth}
  \Large \ttfamily
  \tikzforeground{
    \node[anchor=south](return comma note) at ([xshift=1cm,yshift=1em]return comma.north) {
      \begin{tcolorbox}[code note, width=4cm]
        The \code{,} (comma) tells \kw{return} that we are going to send back more than one piece of data.
      \end{tcolorbox}
    };

    \draw[->] (return comma note.south) -- ([yshift=0.1em]return comma.north);
  }
  \begin{tcolorbox}[sharp corners]
    \tikzmarknode{return dir}{\kw{return}} \tikzmarknode{return direction}{'N'}\tikzmarknode{return comma}{,} \tikzmarknode{return next thought}{'next\_thought'}
  \end{tcolorbox}
\end{minipage}

This time, instead of just returning one thing, we're returning two
things. The first thing we return is which direction we want DuckBot
to go in. This can be:

\begin{itemize}
\item \code{'N'} to go north
\item \code{'E'} to go east
\item \code{'S'} to go south
\item \code{'W'} to go west
\item \code{None} to stay in the same place\hint{\code{None} is a
  special Python value indicating the absence of any data. You don't
  need to put it in quotes. If you did, then you would get the string
  \code{'None'} instead of the special \code{None} value}
\end{itemize}

The second thing we return is DuckBot's next thought. The thought can
be anything: a number or a string or even the \code{None}
value.\hint{You'll probably want your thoughts to mostly be
  strings. This will make your code easier to understand.} You get to
decide!

\subsection{Playing the Game}

When you open DuckBot, load a new level or press the ``Reset Game'' button, the pond is cleared and
DuckBot and the ducklings end up in random parts of the pond.\curious{Actually, the ducklings end up
  in the pond you're least likely to end up in. That's why it's so important DuckBot hits the whole
  pond!}

\section{An Example DuckBot Level}

To make things clearer, let's try working through a single DuckBot level. The first level looks like
this:

% TODO duckbot level 1

DuckBot is placed at a random location. DuckBot's brain is the simple function:

\begin{lstlisting}
def brain(north, east, south, west, thought):
  return None, thought
\end{lstlisting}

What will happen if we start DuckBot with this brain? Let's try it. Click the ``Start Duck'' button
in the control pane (see \prettyref{fig:duckbot}). \hint{Remember, always try to \emph{predict} what
  is going to happen before we do anything on the computer.}

Hmm... that's no good. We want DuckBot to do something. Let's make DuckBot go east.

\hint{Remember to click the ``Reload Brain'' button to make DuckBot use the new brain.}
\begin{TryThisBox}
  Change DuckBot's brain to this:
  \begin{lstlisting}
    def brain(north, east, south, west, thought):
      @@return 'E', thought@@
  \end{lstlisting}
\end{TryThisBox}

If you go ahead and run this, DuckBot will head all the way east until it hits the shore. Remember,
DuckBot is very fragile and does exactly what you tell it. If it hits land, it dies, which is what
happens here. We need to detect when there is an obstacle to the east and send DuckBot in a
different direction.

But, in order to do that, we need to figure out how to make our function \kw{return} one thing if
there is something to the east and \kw{return} another thing if not.

\subsection{Using \kw{if}}

\begin{marginfigure}
  \centering
  \includegraphics[width=0.9\marginparwidth]{../week3/figures/grace-hopper.jpg}
  \caption{Rear Admiral Grace Hopper was a famous computer scientist who invented a programming
    language called \term{COBOL} (\textbf{CO}mmon \textbf{B}usiness-\textbf{O}riented
    \textbf{L}anguage) which was one of the first to usewords like \kw{if} to define how programs
    ran. Before her innovation, computer programs were written using difficult machine code and
    obtuse mathematics. For her fundamental contributions to computer science, she was awarded the
    Presidential Medal of Freedom in 2016.}
  \label{fig:grace-hopper}
\end{marginfigure}

Python comes with a special word that does exactly what we want. This is called \kw{if}, and it works like this:

We write \kw{if} followed by a condition, and then a colon. If the condition is true, then the code
beneath the \kw{if} runs. If the condition is false, then all that code is skipped. This is
illustrated in \prettyref{fig:if-statement}.

To understand what it means to be ``beneath'' the \kw{if}, we have to understand how Python treats
the \code{:}. As we learned last week, Python is sensitive to how things are spaced out. When we
write \kw{def}, we have to put spaces to signify which code is part of our function. The same is
true of \kw{if}. \curious{The error thrown is called \code{IndentationError}.}If we want some code
to run when the condition is true, then all this code must be indented \emph{more} than the \kw{if}
statement. Moreover, all the code has to line up. If you indent one line with six spaces, and the
next line with ten, then Python will return an error.

Let's try using \kw{if} to make DuckBot do something if we have an obstacle to the east.

\hint{Note that it has \emph{two} equal signs. The double equal
  signs compares values. A single equal sign has a different meaning, which we'll explore later.}
\begin{TryThisBox}
  Change DuckBot's brain to this:
  \begin{lstlisting}
    def brain(north, east, south, west, thought):
      @@if east == 'x':
        return 'N', thought@@
      return 'E', thought
  \end{lstlisting}
\end{TryThisBox}

Think about what's going to happen now. When you've decided what you think is going to happen to
DuckBot, hit ``Reload Brain'' and start DuckBot.

Uh-oh! DuckBot once again hit an obstacle, but this time it at least turned towards the north, once
it hit an obstacle to the east.

At this point, maybe it's a good idea to check if there's an obstacle to the north. But which
direction to turn then? North was left of east. We could go west, which is left of north.

Of course, if we did that, DuckBot would just go all the way to the west side of the pond, and hit
the wall there. We'll have to handle the west case as well. And then, if we turn south, DuckBot will
hit the bottom of the pond, so we have to turn back east.

\hint{This is one of those changes where it's really important that you try to \emph{predict} what
  is going to happen.}
\begin{TryThisBox}
  Change DuckBot's brain to this:
  \begin{lstlisting}
    def brain(north, east, south, west, thought):
      if east == 'x':
        return 'N', thought
      @@if north == 'x':
        return 'W', thought
      if west == 'x':
        return 'S', thought
      if south == 'x':
        return 'E', thought@@
      return 'E', thought
  \end{lstlisting}
\end{TryThisBox}

If you go ahead and try that, you'll find that poor DuckBot *still* hits the north shore. Clearly
we've not quite figured out how to make this work.

To understand what's going on, let's consider DuckBot at the northeast corner of the pond (see
\prettyref{fig:duckbot-ne}). At this point, \code{north} and \code{east} are \code{'x'} and
\code{south} and \code{west} are \code{'*'}. You can see this at the bottom left of the DuckBot
interface, which displays the current state of what DuckBot sees.

In the brain view, you'll also notice that some lines are highlighted. The lines highlighted in
light gray represent the code that was used by DuckBot to make its decision. The lines highlighted
in green represent points where decisions were made (i.e., places that used \kw{if}). Finaly, the
line highlighted blue indicate where DuckBot made its decision.

If we look at the interface, we'll see that lines 2 and 3 (see \prettyref{listing:duckbot-circle})
are highlighted, indicating that these are what led to the decision DuckBot made. But that's not
what we wanted. We wanted DuckBot to make the decision to turn West, which is on line 5. The \kw{if}
of line 4 was supposed to check the condition that there was an obstacle to the north. But this line
is not highlighted, indicating it was not used. Why?

If you notice, the \kw{if} that checked the obstacle to the east was used, and then, Python saw that
there was an obstacle to the east when DuckBot was in the northeast square. But, this \kw{if} has a
\kw{return} under it. Because the condition in the \kw{if} was true, Python used the code underneath
it, which told the function to immediately send back its decision to go north. This is not what we
wanted. We have to make sure that there's also no obstacle to the north.

\section{Booleans}

In the above code examples, we skipped over how we wrote the \kw{if} conditions, but it's worth
considering them in more detail right now. How does Python know whether a condition is true or not?
This is important to understand when Python is going to run code.

Try this in your Python prompt:

\begin{replbox}
>>> True
True
>>> False
False
\end{replbox}

These values are two special values used by Python to indicate -- as you'd expect -- whether
something is true or false. The collective term for these kinds of values is \term{booleans}.

Booleans can be combined using symbols, similar to addition and multiplication of numbers. For
example, the symbol \kw{and} checks if both sides are \kw{True}, and returns \kw{True} if they
are.

\begin{replbox}
>>> True and False
False
>>> True and True
True
>>> False and False
False
>>> False and True
False
\end{replbox}

The symbol \kw{or} checks if only one side is \kw{True}.

\begin{replbox}
>>> True or False
True
>>> True or True
True
>>> False or False
False
>>> False or True
True
\end{replbox}

There are only two possibilities for the values on each side of a \kw{and} or \kw{or}. Thus, there
are four possible combinations of values that can go into these symbols. We can write out the entire
set of inputs and outputs as a four-row table. These are called \term{truth tables}. The tables for
\kw{and} and \kw{or} are given in \prettyref{fig:and-or-truth-tables}.

\begin{figure}
  \begin{minipage}{0.45\textwidth}
    \begin{center}
      \begin{tabular}{cc|c}
        \multicolumn{3}{c}{\texttt{x}\;\kw{and}\;\texttt{y}} \\\hline
        \texttt{x} & \texttt{y} & \\\hline
        \kw{True} & \kw{True} & \kw{True} \\
        \kw{True} & \kw{False} & \kw{False} \\
        \kw{False} & \kw{True} & \kw{False} \\
        \kw{False} & \kw{False} & \kw{False} \\\hline
      \end{tabular}
    \end{center}
  \end{minipage}
  \begin{minipage}{0.45\textwidth}
    \begin{center}
      \begin{tabular}{cc|c}
        \multicolumn{3}{c}{\texttt{x}\;\kw{or}\;\texttt{y}} \\\hline
        \texttt{x} & \texttt{y} & \\\hline
        \kw{True} & \kw{True} & \kw{True} \\
        \kw{True} & \kw{False} & \kw{True} \\
        \kw{False} & \kw{True} & \kw{True} \\
        \kw{False} & \kw{False} & \kw{False} \\\hline
      \end{tabular}
    \end{center}
  \end{minipage}

  \caption{These are the truth tables for the \kw{and} and \kw{or} rules. The inputs are in the left two columns and the output is in the right. Try all of these in the Python prompt to verify that they work.}
  \label{fig:and-or-truth-tables}
\end{figure}

\subsection{Inspecting data}

The conditions that we've been using in our \code{brain} functions are an example of comparing
values. Python has several rules and symbols to compare values. We've been using \code{==} which
checks that two things are equal. There are other \term{operators} that check for other
conditions. For a full summary see \prettyref{table:comparisons}.

\begin{replbox}
north == 'x'
\end{replbox}

\begin{table}
  \centering
  \begin{tabular}{lp{0.8\linewidth}}
    \hline
    \headercol{Operator} & \headercol{Explanation} \\\hline
    \code{x == y} & Checks if \code{x} and \code{y} are equal. \\
    \code{x != y} & Checks if \code{x} and \code{y} are not equal. \\
    \code{x < y} & Checks if \code{x} is less than \code{y}. \\
    \code{x > y} & Checks if \code{x} is greater than \code{y}. \\
    \code{x <= y} & Checks if \code{x} is less than or equal to \code{y}. \\
    \code{x >= y} & Checks if \code{x} is greater than or equal to \code{y}. \\
    \code{x is None} & Checks if \code{x} is \kw{None} or empty. \\
    \code{x is not None} & Checks if \code{x} is not \kw{None}. \\\hline
  \end{tabular}
  \caption{Some Python operators that can be used to inspect data that return booleans. Note that
    for strings, \code{x < y} means that \code{x} comes before \code{y} in standard alphabetical
    order.}
  \label{table:comparisons}
\end{table}

These rules result in booleans. Let's try it.

\begin{replbox}
>>> 'x' == 'x'
True
>>> 'x' == 'y'
False
>>> 4 < 5
True
>>> 4 >= 5
False
\end{replbox}


\subsection{Infinite Loops}

Consider what's happening here: although DuckBot no longer breaks, it also is not fully
working. \curious{DuckBot not breaking but also not being able to tell you that anything is wrong is
  an example of a kind of behavior that's broken but that Python cannot report as an error: there is
  no Python rule you are breaking. Python faithfully carries out exactly the rules you gave to it.}



\begin{TryThisBox}
  Try going through all the DuckBot levels. For hints, see the exercises at the end of the chapter.
\end{TryThisBox}

\section{Algorithms}

An algorithm is characterized by its inputs and the exact sequence of steps you must follow to get
some result. For example, a common algorithm we are familiar with involves adding two numbers. Then,
the algorithm goes as follows:

% TODO demonstrate

\begin{enumerate}

\item Place both numbers you want to add and align units, starting with the ones place.
\item Proceed to add single digits starting with the ones place.
\item If the sum of the single digits is greater than 9, place the digits from the tens place and beyond into the columns of the higher places.
\item Proceed to the next place

\end{enumerate}

\curious{The first computers were literally implemented as a series of on-off switches. Engineers would manually connect large electronically-operated switches known as relays to create machines that could calculate automoatically. Pictured below is the Harvard Mark I which was one of the first electromechanical computers ever built.} Another way of thinking about an algorithm is a series of decisions. It may not seem like it right
now, but everything we did above can be turned into a series of yes or no questions. The answers to
these questions choose the next step that ought to be done. This becomes more clear if we re-state
the addition procedure above over the binary numbers.

% TODO demonstrate



\section{Implementing an Algorithm}

Once you've thought through what the algorithm ought to do. 

\section{Numbers All the Way Down}

Last week, we discussed how computers store numbers using switches that are either on or
off. \hint{See \prettyref{sec:binary-numbers} for a review.}

Everything on a computer is stored as numbers. Even the words we saw last class are stored using
numbers. Every letter in a word (or a \term{string} as Python calls it) is assigned a number. We
call these numbers the \term{encoding} of the string.\hint{Python will sometimes abbreviate \term{string} as \code{str}.}

Most modern computers today use the \term{Unicode} standard for encoding strings. Unicode is a
\emph{huge} dictionary mapping every character possibly known to humans to a number assigned by an
international committee.\didyouknow{As of the latest Unicode standard, there are over 297,334
  characters! That's a lot of letters!} Before Unicode standardized the mapping of characters,
computer systems would often use their own custom standard or a standard particular to individual
countries and languages. Reading files created using one standard on a computer designed to work
with another standard could result in garbage data. Another common way to write strings as numbers
is called \term{ASCII}, which stands for the \emph{American Standard Code for Information
Interchange}. ASCII covers most characters used in English and other languages that use the Latin
alphabet. It's also compatible with Unicode -- Unicode maps every Latin letter to the same ASCII
character.

It may seem crazy that each letter has a number that goes along with it, but I can prove it to you. Try this in Python:

\hint{If you want to see a new kind of error called a \code{ValueError}, try\\
\code{ord('hello')}!}
\begin{replbox}
>>> ord('5')<ENTER>
53
>>> ord('Z')<ENTER>
90
>>> ord('>')<ENTER>
62
>>> ord('\'')<ENTER>(*@ \tikzmarknode{python escapes node}{} @*)
39
>>> ord('h')<ENTER>
104
\end{replbox}
\makemargmark{python escapes node}{\notestyle\hintnote Python words are delimited by single quotation marks (\code{'}). But what if you want to talk about the word consisting of just the single quote character itself or a word containing a single quote character (like an Irish name with \enquote{O'})? In order to tell Python that you want a \code{'} treated as just the letter and not part of the Python rules, you use the \code{\textbackslash} character in front of it. This word \code{'\textbackslash''} is just the word consisting of a single single-quote letter.}
%}


You can also go from a number \emph{to} a word.

\hint{Try all kinds of numbers here, and see what you get!}
\begin{replbox}
>>> chr(76)<ENTER>
'L'
>>> chr(53)<ENTER>
'5'
>>> chr(54)<ENTER>
'6'
>>> chr(233)<ENTER>
'Ã©'
>>> chr(1103)<ENTER>
'Ñ'
>>> chr(26159)<ENTER>
'æ˜¯'
>>> chr(22398)<ENTER>
'å­¦'(*@\tikzmarknode{chinese xie}{}@*)
>>> chr(128512)<ENTER>
'(*@{\EmojiFont ðŸ˜€}@*)'
\end{replbox}
\makemargmark{chinese xie}{\hintnote \enquote{å­¦}(\emph{xi\`e}) means to learn in Mandarin. That's what we're doing right now, and you just learned something new!}

Lest we forget that it's still all just ones and zeros, you can use the \code{bin} rule that we
learned about last week to see the binary representation of these numbers.

\begin{replbox}
>>> bin(ord('5'))<ENTER>
'0b100111'(*@\tikzmarknode{single quotes around binary numbers}{}@*)
>>> bin(ord('Z'))<ENTER>
'0b1011010'
>>> bin(ord('\''))<ENTER>
'0b100111'
\end{replbox}
\makemargmark{single quotes around binary numbers}{\notestyle\huhnote{I thought the single quotes meant words. Why do we keep seeing them when we ask for binary numbers?}\\
Because Python is friendly, it always shows numbers as decimal, even though they are stored as binary on the computer. The \code{bin} rule actually creates a word, or string, that represents the binary representation. This lets you see it here.}

See it's just numbers all the way down!

\begin{BigIdeaBox}
  All information inside a modern computer is stored as numbers, even words!
\end{BigIdeaBox}
