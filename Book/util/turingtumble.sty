% turingtumble.tikzlibrary.tex
% Stylized "Turing Tumble" board drawing helpers (diagramming, not simulation)
%
% Usage:
%   \input{turingtumble.tikzlibrary.tex}
%   \begin{tikzpicture}
%     \TTBoard[cols=8,rows=10,pegs=true]
%     \TTBit{3}{6}[state=0]
%     \TTMarble{1}{10}
%     \TTArrow{1}{10}{2}{9}
%   \end{tikzpicture}

\ProvidesPackage{turingtumble}[2026/01/11 Stylized Turing Tumble Tikz helpers]

\RequirePackage{tikz}
\RequirePackage{xcolor}
\usetikzlibrary{arrows.meta,calc,positioning,intersections}

\definecolor{marblered}{RGB}{170,40,40}
\definecolor{marbleblue}{RGB}{40,70,160}

\def\TTGfxBit#1#2{
  \pgfmathsetmacro{\TTBitScale}{-2 * #2 + 1}
  \node[anchor=north east] at ($#1 + ({0.681926*\TTXUnit}, {0.65*\TTYUnit})$) {\scalebox{\TTBitScale}[1]{\includegraphics[width=\TTXUnit, height=\TTYUnit]{util/piece-bit.pdf}} }
}
\def\TTGfxGearBit#1#2{
  \pgfmathsetlengthmacro{\TTGearbitW}{1.1 * \TTXUnit}
  \pgfmathsetlengthmacro{\TTGearbitH}{0.7 * \TTYUnit}
  \pgfmathsetmacro{\TTBitScale}{-2 * #2 + 1}
  \node[anchor=north east] at ($#1 + ({0.681926*\TTXUnit}, {0.65*\TTYUnit})$) {\scalebox{\TTBitScale}[1]{\includegraphics[width=\TTGearbitW, height=\TTGearbitH]{util/piece-gearbit.pdf}} }
}
%\def\TTGfxInterceptor#1{
%  \node[anchor=north east] at ($#1 + ({0.8*\TTXUnit}, {0.68*\TTYUnit})$) {\scalebox{1.1}[0.7]{\includegraphics[width=\TTXUnit, height=\TTYUnit]{util/piece-interceptor.pdf}} }
%}
\def\TTGfxInterceptor#1{
  \pgfmathsetlengthmacro{\TTInterceptorW}{1.1 * \TTXUnit}
  \pgfmathsetlengthmacro{\TTInterceptorH}{0.7 * \TTYUnit}
  \node[anchor=north east, inner sep=0, transform shape] at ($#1 + ({0.55 * \TTXUnit}, {0.44 * \TTYUnit})$) {\includegraphics[width=\TTInterceptorW, height=\TTInterceptorH]{util/piece-interceptor.pdf}};
}

\def\TTGfxCrossover#1{\node[anchor=north east] at ($#1 + ({0.68*\TTXUnit}, {0.65*\TTYUnit})$) {\includegraphics[width=\TTXUnit, height=\TTYUnit]{util/piece-crossover.pdf}} }
\def\TTGfxRamp#1#2{\node[anchor=north east] at ($#1 + ({0.68*\TTXUnit}, {0.65*\TTYUnit})$) {\scalebox{#2}[1]{\includegraphics[width=\TTXUnit, height=\TTYUnit]{util/piece-ramp.pdf}} }}
\def\TTGfxGear#1{\node[anchor=north east] at ($#1 + ({0.68*\TTXUnit}, {0.65*\TTYUnit})$) {\includegraphics[width=\TTXUnit, height=\TTYUnit, angle=15]{util/piece-gear.pdf}} }

\def\ttbitcharleft{\includegraphics[width=1em]{util/piece-bit.pdf}\;}
\def\ttbitcharright{\scalebox{-1}[1]{\includegraphics[width=1em]{util/piece-bit.pdf}}\;}
\def\ttmarbleredchar{\textcolor{marblered}{\Large $\bullet$}}
\def\ttmarblebluechar{\textcolor{marbleblue}{\Large $\bullet$}}

\ExplSyntaxOn
\cs_new_protected:Npn \tt_pieces:n #1
   {
     \tl_map_inline:nn {#1}
           {
             \str_case:nnF{##1}
                 {
                   {0}{\ttbitcharleft}
                   {1}{\ttbitcharright}
                   {r}{\ttmarbleredchar}
                   {b}{\ttmarblebluechar}
                 }
                 {
                   \msg_error:nnn{tt}{bad-char}{##1}
                 }
           }
   }
\NewDocumentCommand{\ttpieces}{m}{\tt_pieces:n {#1}}
\ExplSyntaxOff

\newcommand{\ttbits}

% ----------------------------
% Key-value configuration
% ----------------------------
\pgfkeys{
  /tt/.is family, /tt,
  /tt/small/.style={x unit=5mm,y unit=5.5mm},
  /tt/margin/.style={x unit=4mm, y unit=5mm},
  output/.initial=,
  cols/.initial=11,
  rows/.initial=11,
  x unit/.initial=7mm,        % grid spacing
  y unit/.initial=8mm,
  blue marbles/.initial=0,
  red marbles/.initial=0,
  blue marbles released/.initial=0,
  red marbles released/.initial=0,
  pegs/.initial=true,
  peg radius/.initial=1.2pt,
  pin radius/.initial=0.7pt,
  board round/.initial=4pt,
  board thick/.initial=0.9pt,
  peg color/.initial=gray,
  board color/.initial=gray,
  start offset/.initial=3,
  start around/.initial=1,
  end around/.initial=0,
  label/.initial=,
  wiggle color/.initial=gray,
}

% Piece keys
\pgfkeys{
  /tt/piece/.is family, /tt/piece,
  name/.initial=,
  fill/.initial=gray!10,
  draw/.initial=black,
  line/.initial=0.7pt,
}

\pgfkeys{
  /tt/bit/.is family, /tt/bit,
  gear/.style={isgear=1},
  state/.initial=0, % 0 or 1
  isgear/.initial=0,
  on/.style={state=1},
  off/.style={state=0}
}

\pgfkeys{
  /tt/marble/.is family, /tt/marble,
  fill/.initial=white,
  draw/.initial=black,
  r/.initial=1.7pt,
}

\pgfkeys{
  /tt/arrow/.is family, /tt/arrow,
  style/.initial={thick}, %-Latex},
  label/.initial=,
  label pos/.initial=0.5,
  label opts/.initial={font=\small,fill=white,inner sep=1pt},
}

% ----------------------------
% Coordinate system helpers
% ----------------------------
% We draw on a staggered peg grid like a Galton board:
% Even rows have pegs at integer x; odd rows shifted by +0.5.
%
% \TTCoord{x}{y} expands to a coordinate
\newcommand{\TTCoord}[2]{({#1 * \TTXUnit},{(\TTRows - #2 - 1) * \TTYUnit})}

% Named coordinate for later use: \TTMark{name}{x}{y}
\newcommand{\TTMark}[3]{%
  \coordinate (#1) at \TTCoord{#2}{#3};
}

% ----------------------------
% TikZ styles
% ----------------------------
\tikzset{
  tt/peg/.style={circle, draw=\pgfkeysvalueof{/tt/peg color}, fill=none, inner sep=\pgfkeysvalueof{/tt/peg radius}},
  tt/board/.style={rounded corners=\pgfkeysvalueof{/tt/board round}, draw=\pgfkeysvalueof{/tt/board color}, line width=\pgfkeysvalueof{/tt/board thick}, color=\pgfkeysvalueof{/tt/board color}},
  tt/piecebox/.style={rounded corners=2pt, draw, line width=\pgfkeysvalueof{/tt/piece/line}, fill=\pgfkeysvalueof{/tt/piece/fill}},
  tt/marble/.style={circle, draw=\pgfkeysvalueof{/tt/marble/draw}, fill=\pgfkeysvalueof{/tt/marble/fill}, inner sep=\pgfkeysvalueof{/tt/marble/r}},
}

% ----------------------------
% Board macro
% ----------------------------
% \TTBoard[cols=...,rows=...,unit=...,pegs=true,label=...]
\newenvironment{ttboard}[1][]{ %\newcommand{\TTBoard}[1][]{%
  \pgfkeys{/tt, #1}%
  \def\TTCols{\pgfkeysvalueof{/tt/cols}}%
  \def\TTRows{\pgfkeysvalueof{/tt/rows}}%
  \def\TTPegStart{\pgfkeysvalueof{/tt/start offset}}
  \def\TTPegAround{\pgfkeysvalueof{/tt/start around}}
  \def\TTEndAround{\pgfkeysvalueof{/tt/end around}}
  \def\TTBoardColor{\pgfkeysvalueof{/tt/board color}}
  \pgfmathsetlengthmacro\TTPinRadius{\pgfkeysvalueof{/tt/pin radius}}
  \pgfmathsetlengthmacro\TTXUnit{\pgfkeysvalueof{/tt/x unit}}%
  \pgfmathsetlengthmacro\TTYUnit{\pgfkeysvalueof{/tt/y unit}}
  \pgfmathsetlengthmacro\TTPad{\TTXUnit * 0.6}
  \pgfmathsetlengthmacro\TTPegRadius{\pgfkeysvalueof{/tt/peg radius}}
  \def\TTLabel{\pgfkeysvalueof{/tt/label}}%
  \pgfmathsetlengthmacro{\TTMidBoard}{((\TTCols - 1) * \TTXUnit) / 2}
  \pgfmathsetlengthmacro{\TTTopOfBoard}{\TTRows*\TTYUnit+\TTPad*1.5} %+ \TTBoardHeader}

  \pgfmathsetmacro{\TTMiddleCoord}{floor(\TTCols/2)}
  \pgfmathsetlengthmacro{\TTFooter}{\TTYUnit * 3}
  \pgfmathsetlengthmacro{\TTWiggleOffset}{\TTYUnit * 0.2 + \TTPinRadius}

  % Given a row number calculate the 'left cone' and the 'right cone'
  \def\TTCalcOffsets{
    \pgfmathsetmacro{\TTLeftConeStart}{\TTPegStart - \TTPegAround - \yy}
    \pgfmathsetmacro{\TTLeftConeEnd}{\TTPegStart + \TTPegAround + \yy}
    \pgfmathsetmacro{\TTRightConeStart}{\TTCols - \TTPegStart - \TTPegAround - \yy - 1}
    \pgfmathsetmacro{\TTRightConeEnd}{\TTCols - \TTPegStart + \TTPegAround + \yy - 1}
  }

  % Outer board rectangle
  \pgfmathsetmacro{\TTReleaseDrop}{\TTPad * 1.3}
  \pgfmathsetmacro{\releaseguardangle}{(45/360) * 2 * pi}
  \pgfmathsetlengthmacro\releaseguardoffsetx{cos(\releaseguardangle r) * \TTPad}
  \pgfmathsetlengthmacro\releaseguardoffsety{sin(\releaseguardangle r) * \TTPad}
  \pgfmathsetlengthmacro{\TTBoardRight}{(\TTCols - 1)*\TTXUnit+\TTPad}
  \pgfmathsetlengthmacro{\TTBoardBottom}{-\TTPad-\TTFooter}
  \pgfmathsetlengthmacro{\TTBoardLeft}{-\TTPad}
  \pgfmathsetlengthmacro{\TTBoardTop}{\TTTopOfBoard}

    \draw[tt/board]
    (\TTBoardLeft,\TTBoardBottom) rectangle (\TTBoardRight,\TTTopOfBoard) coordinate (ttboardtop);

  % Releases atop the board (circles that release blue and red marbles
  \draw[name=leftrelease, fill=\TTBoardColor, color=\TTBoardColor] (0, {\TTTopOfBoard - \TTReleaseDrop}) circle (\TTPad);
  \draw[name=rightrelease, fill=\TTBoardColor, color=\TTBoardColor] ({(\TTCols-1)*\TTXUnit}, {\TTTopOfBoard - \TTReleaseDrop}) circle (\TTPad);
  \node[tt/peg, fill=marbleblue] (leftreleasepeg) at (0, {\TTTopOfBoard - \TTReleaseDrop}) {};
  \node[tt/peg, fill=marblered] (rightreleasepeg) at ({(\TTCols - 1) * \TTXUnit}, {\TTTopOfBoard - \TTReleaseDrop}) {};

  \draw[color=\TTBoardColor] ({1.5 * \TTXUnit}, \TTTopOfBoard) to [bend left] ++({-\TTXUnit/4},{-\TTXUnit/4}) -- ($(leftreleasepeg.center) + (\releaseguardoffsetx,\releaseguardoffsety)$);
  \draw[color=\TTBoardColor] ({((\TTCols - 1) - 1.5) * \TTXUnit}, \TTTopOfBoard) to [bend right] ++({\TTXUnit/4},{-\TTXUnit/4}) -- ($(rightreleasepeg.center) + (-\releaseguardoffsetx, \releaseguardoffsety)$);

  % Slopes of ramp
  \pgfmathsetmacro{\TTBlueMarbles}{\pgfkeysvalueof{/tt/blue marbles}}
  \pgfmathsetmacro{\TTBlueMarblesReleased}{\pgfkeysvalueof{/tt/blue marbles released}}
  \pgfmathsetmacro{\TTBlueMarblesShow}{\TTBlueMarbles > 0}
  \pgfmathsetmacro{\TTBlueMarblesReleasedShow}{\TTBlueMarblesReleased > 0}
  \def\TTBlueSlopeMarbles{\ifnum\TTBlueMarblesReleasedShow=1\relax
    \foreach \i in {1,...,\TTBlueMarblesReleased} {\ttmarblebluechar}
  \fi}
  \def\TTBlueUpperMarbles{\ifnum\TTBlueMarblesShow=1\relax
    \foreach \i in {1,...,\TTBlueMarbles} {\ttmarblebluechar}
    \fi}
  \pgfmathsetmacro{\TTRedMarbles}{\pgfkeysvalueof{/tt/red marbles}}
  \pgfmathsetmacro{\TTRedMarblesReleased}{\pgfkeysvalueof{/tt/red marbles released}}
  \pgfmathsetmacro{\TTRedMarblesShow}{\TTRedMarbles > 0}
  \pgfmathsetmacro{\TTRedMarblesReleasedShow}{\TTRedMarblesReleased > 0}
  \def\TTRedSlopeMarbles{\ifnum\TTRedMarblesReleasedShow=1\relax
    \foreach \i in {1,...,\TTRedMarblesReleased} {\ttmarbleredchar}
    \fi}
  \def\TTRedUpperMarbles{\ifnum\TTRedMarblesShow=1\relax
    \foreach \i in {1,...,\TTRedMarbles} {\ttmarbleredchar}\fi}

  \draw[color=\TTBoardColor] (\TTMidBoard, \TTTopOfBoard) -- ++(0,-\TTPad) coordinate (midboardbar) -- ++({-\TTMidBoard + 1 * \TTXUnit}, {-0.2 * \TTYUnit}) node[pos=1.15,sloped,above=-0.08,anchor=south west] {\TTBlueUpperMarbles};
  \draw[color=\TTBoardColor] (midboardbar) -- ++({\TTMidBoard - 1 * \TTXUnit}, {-0.2 * \TTYUnit}) node[pos=1.15,sloped,above=-0.08,anchor=south east] {\TTRedUpperMarbles};

  \coordinate (leftreleaseslopestart) at ($(leftreleasepeg.center) + (0, -\TTPad)$);
  \coordinate (leftentrance) at ($(leftreleaseslopestart) + ({2.5 * \TTXUnit}, {-0.1 * \TTYUnit})$);
  \coordinate (rightreleaseslopestart) at ($(rightreleasepeg.center) + (0, -\TTPad)$);
  \coordinate (rightentrance) at ($(rightreleaseslopestart) + ({-2.5 * \TTXUnit}, {-0.1 * \TTYUnit})$);
  \draw[color=\TTBoardColor] (leftreleaseslopestart) -- (leftentrance) node [pos=1.15,sloped,above=-0.08,anchor=south east] {\TTBlueSlopeMarbles};
  \draw[color=\TTBoardColor] (rightreleaseslopestart) -- (rightentrance) node[pos=1.15,sloped,above=-0.08,anchor=south west] {\TTRedSlopeMarbles};

  % footer
  \draw[color=\TTBoardColor] (-\TTPad,0) coordinate (leftportalstart) -- ({(\TTMiddleCoord - 1) * \TTXUnit}, {-\TTYUnit/2}) coordinate (leftportal);
  \draw[color=\TTBoardColor] (\TTBoardRight, 0) coordinate (rightportalstart) -- ({(\TTMiddleCoord + 1) * \TTXUnit}, {-\TTYUnit/2}) coordinate (rightportal);

  \coordinate (leftleverpeg) at ({(\TTMiddleCoord - 3.5) * \TTXUnit}, {-\TTYUnit});
  \coordinate (rightleverpeg) at ({(\TTMiddleCoord + 3.5) * \TTXUnit}, {-\TTYUnit});
  \coordinate (leftportalaim) at ($(leftportal)!-0.5*\TTXUnit!(leftportalstart)$);
  \coordinate (rightportalaim) at ($(rightportal)!-0.5*\TTXUnit!(rightportalstart)$);

  \draw[line width={6 * \TTPegRadius}, color=\TTBoardColor, name path=leftlever] (leftportalaim) -- ($(leftleverpeg)!-\TTXUnit!(leftportal)$) coordinate (leftleverweight);
  \draw[line width={6 * \TTPegRadius}, color=\TTBoardColor, name path=rightlever] (rightportalaim) -- ($(rightleverpeg)!-\TTXUnit!(rightportal)$) coordinate (rightleverweight);
  \draw[fill=white] (rightleverpeg) circle (\TTPegRadius);
  \draw[fill=white] (leftleverpeg) circle (\TTPegRadius);

  \draw[fill=\TTBoardColor,color=\TTBoardColor] (leftleverweight) circle (0.8 * \TTPad);
  \draw[fill=\TTBoardColor,color=\TTBoardColor] (rightleverweight)  circle (0.8 * \TTPad);
  \draw[fill=marbleblue, color=marbleblue] (leftleverweight) circle ({2 * \pgfkeysvalueof{/tt/peg radius}});
  \draw[fill=marblered, color=marblered] (rightleverweight) circle ({2 * \pgfkeysvalueof{/tt/peg radius}});

  % footer landings
  \path let \p{peg} = (leftleverpeg),
            \p{aim} = (leftportalaim)
        in (\x{aim}, 2 * \y{peg} - \y{aim}) coordinate (leftlanding);
  \draw[color=\TTBoardColor] ([shift={(-135:6*\TTPegRadius)}]leftlanding) arc (-135:-45:6*\TTPegRadius);

  \path let \p{peg} = (rightleverpeg),
            \p{aim} = (rightportalaim)
        in (\x{aim}, 2 * \y{peg} - \y{aim}) coordinate (rightlanding);
  \draw[color=\TTBoardColor] ([shift={(-100:6*\TTPegRadius)}]rightlanding) coordinate (rightdrop) arc (-100:-45:6*\TTPegRadius);

  \draw[color=\TTBoardColor] (rightdrop) to [bend left] ++({-6*\TTPegRadius},{-6*\TTPegRadius}) -- ++({-(\TTCols*0.4)*\TTXUnit}, {-0.4*\TTYUnit}) coordinate (rightdropend);
  \begin{scope}[overlay]
    \path[name path=dropLine]
    ($(rightdrop)!-10!(rightdropend)$) -- ($(rightdrop)!10!(rightdropend)$);
    \path[name path=yaxis]
    (-\TTPad,-10) -- (-\TTPad,10);
    \path[name intersections={of=dropLine and yaxis, by=finalDrop}];
  \end{scope}
  \draw[color=\TTBoardColor] ($(finalDrop)+(0,{0.1*\TTYUnit})$) to [bend right] ++({6 * \TTPegRadius}, {-6 * \TTPegRadius}) -- ({(\TTCols -2)*\TTXUnit}, {-\TTPad-\TTFooter}) node[pos=1, sloped, above, anchor=south east]{\pgfkeysvalueof{/tt/output}};

  % Optional label/title
  \ifx\TTLabel\empty\else
    \node[font=\small] at (\TTMidBoard, \TTTopOfBoard+1.2em) {\sffamily\bfseries \TTLabel};
  \fi

  \def\drawpeg{
    \begin{scope}
      \pgfmathsetmacro{\TTHasWiggle}{mod(\yy + mod(\xx,2), 2) == 1}
      \node[tt/peg] (peg) at \TTCoord{\xx}{\yy} {};
      \ifnum\TTHasWiggle=1\relax
        \draw[color=\pgfkeysvalueof{/tt/wiggle color},line width={2*(\TTPinRadius + 0.3pt)}, line cap=round] ([shift={(-135:\TTWiggleOffset)}]peg) arc (-135:-45:\TTWiggleOffset);
        \draw[white,line width={2*\TTPinRadius}, line cap=round] ([shift={(-135:\TTWiggleOffset)}]peg) arc (-135:-45:\TTWiggleOffset);
      \fi
    \end{scope}
  }

  % Peg grid
  \edef\TTPegs{\pgfkeysvalueof{/tt/pegs}}%
  \def\TTtrue{true}%
  \ifx\TTPegs\TTtrue
    \foreach \y in {1,...,\TTRows} {
      \pgfmathsetmacro{\yy}{\y - 1}
      \TTCalcOffsets
      \foreach \x in {1,...,\TTCols} {
        \pgfmathsetmacro{\xx}{\x - 1}
        \pgfmathparse{
          ((\xx >= \TTLeftConeStart) && (\xx <= \TTLeftConeEnd)) ||
          ((\xx >= \TTRightConeStart) && (\xx <= \TTRightConeEnd))}
        \ifnum\pgfmathresult=1\relax
        % compute staggered x position
%        \pgfmathsetmacro{\xs}{\x + (mod(\y,2)==0 ? 0 : 0.5)}
        % Only draw if inside board
        \pgfmathparse{\y == \TTRows}
        \ifnum\pgfmathresult=1\relax
          \pgfmathsetmacro{\TTEndConeStart}{\TTMiddleCoord - \TTEndAround}
          \pgfmathsetmacro{\TTEndConeEnd}{\TTMiddleCoord + \TTEndAround}
          \pgfmathparse{(\xx >= \TTEndConeStart) && (\xx <= \TTEndConeEnd)}
          \ifnum\pgfmathresult=1\relax
            \drawpeg
          \fi
        \else
          \drawpeg
        \fi
        \fi
      }
    }
  \fi
}{}

% ----------------------------
% Marble and arrows
% ----------------------------
% \TTMarble{x}{y}[fill=...,draw=...,r=...]
\newcommand{\TTMarble}[3][]{%
  \pgfkeys{/tt/marble, #1}%
  \node[tt/marble] at \TTCoord{#2}{#3} {};
}

% \TTArrow{x1}{y1}{x2}{y2}[style=...,label=...]
\newcommand{\TTArrow}[5][]{%
  \pgfkeys{/tt/arrow, #1}%

  \pgfkeysgetvalue{/tt/arrow/style}{\TTArrowStyle}%
  \pgfkeysgetvalue{/tt/arrow/label}{\TTArrowLabel}%
  \pgfkeysgetvalue{/tt/arrow/label pos}{\TTArrowLabelPos}%
  \pgfkeysgetvalue{/tt/arrow/label opts}{\TTArrowLabelOpts}%

    % 1) Always draw the arrow line
    \draw[\expandafter\@firstofone\TTArrowStyle]
      \TTCoord{#2}{#3} -- \TTCoord{#4}{#5};

    % 2) Only add the label as a separate path (no TikZ parser weirdness)
    \edef\tt@lab{\TTArrowLabel}%
    \ifx\tt@lab\pgfutil@empty
      % no label
    \else
      \path
        \TTCoord{#2}{#3} -- \TTCoord{#4}{#5}
        node[pos=\TTArrowLabelPos] {\TTArrowLabel};
    \fi
}

% ----------------------------
% Pieces (stylized)
% ----------------------------

% 1) Bit
% \TTBit{x}{y}[state=0|1,name=...]
\newcommand{\TTBit}[3][]{%
  \pgfkeys{/tt/piece, /tt/bit, #1}%
  \def\TTBitState{\pgfkeysvalueof{/tt/bit/state}}%
  \def\TTBitIsGear{\pgfkeysvalueof{/tt/bit/isgear}}
  \def\TTName{\pgfkeysvalueof{/tt/piece/name}}%
  \node (tt@bit@pos) at \TTCoord{#2}{#3} {};
  \ifnum\TTBitIsGear=0
  \TTGfxBit{(tt@bit@pos)}{\TTBitState};
  \else
  \TTGfxGearBit{(tt@bit@pos)}{\TTBitState};
  \fi
  \node[tt/peg, fill=white] at (tt@bit@pos) {};
  % optionally name the coordinate
  \ifx\TTName\empty\else
  \coordinate (\TTName) at (tt@bit@pos);
  \fi
}

% 2) Ramp (deflector). direction = L or R
% \TTRampL{x}{y}[name=...]
% \TTRampR{x}{y}[name=...]

\pgfkeys{/tt/ramp/.is family, /tt/ramp,
  left/.style={dir=-1},
  right/.style={dir=1},
  dir/.initial=1,
}

\newcommand{\TTRamp}[3][]{%
  \pgfkeys{/tt/piece, /tt/ramp, #1}%
  \edef\TTDir{\pgfkeysvalueof{/tt/ramp/dir}}%
  \def\TTName{\pgfkeysvalueof{/tt/piece/name}}%
  \node (tt@ramp@pos) at \TTCoord{#2}{#3} {};

  \TTGfxRamp{(tt@ramp@pos)}{\TTDir};
  \node[tt/peg, fill=white] at (tt@ramp@pos) {};
  \ifx\TTName\empty\else
  \coordinate (\TTName) at (tt@ramp@pos);
  \fi
}

\newcommand\TTRampRun[3]{
  \edef\TTHole{#1}
  \edef\TTRowStart{#2}
  \pgfmathsetmacro{\TTRowEnd}{#3}

  \foreach \y in {\TTRowStart, ..., \TTRowEnd} {
    \pgfmathsetmacro{\TTWiggleOff}{mod(\y + mod(\TTHole, 2),2) == 0}
    \pgfmathsetmacro{\TTWiggleCol}{\TTHole + \TTWiggleOff}
    \ifnum\TTWiggleOff=1\relax
    \TTRamp[left]{\TTWiggleCol}{\y}
    \else
    \TTRamp[right]{\TTWiggleCol}{\y}
    \fi
  }
}

% 3) Crossover (two paths cross without interacting, schematic X)
% \TTCrossover{x}{y}[name=...]
\newcommand{\TTCrossover}[3][]{%
  \pgfkeys{/tt/piece, #1}%
  \def\TTName{\pgfkeysvalueof{/tt/piece/name}}%

  \node (tt@crossover@pos) at \TTCoord{#2}{#3} {};
  \TTGfxCrossover{(tt@crossover@pos)};
  \node[tt/peg, fill=white] at (tt@crossover@pos) {};
  \ifx\TTName\empty\else
  \coordinate (\TTName) at (tt@crossover@pos);
  \fi
}

% 4) Interceptor-ish "Gate" (simple: blocks one side, passes other)
% This is NOT product-accurateâ€”it's a diagram symbol.
% \TTGate{x}{y}[open=L|R,name=...]
\newcommand{\TTInterceptor}[3][]{%
  \pgfkeys{/tt/piece, #1}
  \def\TTName{\pgfkeysvalueof{/tt/piece/name}}%

  \node (tt@interceptor@pos) at \TTCoord{#2}{#3} {};
  \TTGfxInterceptor{(tt@interceptor@pos)}
  \node[tt/peg, fill=white] at (tt@interceptor@pos) {};
  \ifx\TTName\empty\else
  \coordinate (\TTName) at (tt@interceptor@pos);
  \fi
}

\newcommand{\TTGear}[3][]{%
  \pgfkeys{/tt/piece, #1}
  \def\TTName{\pgfkeysvalueof{/tt/piece/name}}%

  \node (tt@gear@pos) at \TTCoord{#2}{#3} {};
  \TTGfxGear{(tt@gear@pos)};
  \node[tt/peg, fill=white] at (tt@gear@pos) {};
  \ifx\TTName\empty\else
  \coordinate (\TTName) at (tt@gear@pos);
  \fi
}

% ----------------------------
% Convenience: show "rule arrows" around a piece
% ----------------------------
% \TTBitRuleArrows{x}{y}[state=0|1]
% Draws incoming arrow to bit and outgoing left/right arrows labeled 0/1.
\newcommand{\TTBitRuleArrows}[3][]{%
  \pgfkeys{/tt/bit, #1}%
  \def\TTBitState{\pgfkeysvalueof{/tt/bit/state}}%
  % incoming (above -> center)
  \TTArrow[style={-Latex, thick}]{#2}{#3+2}{#2}{#3+1}[label=]
  % outgoing possibilities (below to left/right)
  \TTArrow[style={-Latex, thick},label={0}]{#2}{#3}{#2-1}{#3-1}
  \TTArrow[style={-Latex, thick, dashed},label={1}]{#2}{#3}{#2+1}{#3-1}
}
